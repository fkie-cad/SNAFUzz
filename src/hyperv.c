// 
// Hypervisor implementation based of the Windows Hypervisor Platform APIs.
// 
// In Snapshot Mode, we use a hypervisor to give the user reasonable
// performance, when setting up their snapshots. 
// We set the hypervisor up to exit on most events, with one notable exception
// being rdtsc (But you can exit on rdtsc using the 'HYPERVISOR_EXIT_ON_RDTSC'
// define in options.c). 
// Whenever the hypervisor exits, we translate all cpu-state into our own
// structures, handle the event and then translate all state back and continue executing. 
// Most events have an equivalent helper in instruction_helpers.c (e.g.: 'write_to_port_helper'), 
// but some have special handling for the hypervisor.
// 
// For Memory Mapped I/O (only really the I/O Apic and the VMBUS monitor pages),
// we unmap the corresponding guest physical pages and handle the access in the 
// 'WHvRunVpExitReasonMemoryAccess' case.
// 
// Because the Hypervisor is designed for Snapshot Mode, it has
// to support the VMBUS devices and timer interrupts. 
// Both the timer interrupts as well as keystrokes and mouse events
// are generated by the screen implementation in 'hacky_display.c'.
// All state is communicated through a set of global variables.
// Whenever 'hacky_display.c' wants the hypervisor to handle some event,
// it calls into 'cancel_virtual_processor', which causes the Hypervisor
// to wake-up and check for 'hacky_display_input_handling' or if there is none, 
// it 'helper_send_timer_interrupt' and finally 'set_next_timer_interrupt'.
// 
// As we do implement timer interrupts and (per default) don't cause VMEXITs
// on rdtsc, the hypervisor is non-deterministic. When disabling timer interrupts
// and exiting on rdtsc, the only non-deterministic thing is the APIC timer, 
// but they don't seem to use this timer too much.
// 
// The debugger is implemented by using the debug registers (dr0 - dr7).
// Single stepping works by setting a breakpoint on 'get_address_of_next_instruction'.
// When an exception occurs, the hypervisor exits and we can set a breakpoint 
// on the interrupt vector.
// 
// Interrupts are implemented by using the 'WHvRequestInterrupt' API. 
// One complication here is the auto-eoi feature required for the 
// synthetic interrupt vectors (SINT). Here, we request an interrupt,
// but set a breakpoint on the interrupt vector. Once, the breakpoint 
// hits, we 'hypervisor_perform_end_of_interrupt' which 
// 'WHvGetVirtualProcessorInterruptControllerState2' and
// 'WHvSetVirtualProcessorInterruptControllerState2' to clear the 
// corresponding bit in the 'in_service_register'.
// 
//                                               - Pascal Beyer 29.02.2024
// 

HANDLE initialize_hypervisor(void){
    
    HANDLE Partition;
    s32 Result;
    u32 BytesWritten = 0;
    
    u64 HypervisorPresent = 0;
    Result = WHvGetCapability(/*WHvCapabilityCodeHypervisorPresent*/0, &HypervisorPresent, sizeof(HypervisorPresent), &BytesWritten);
    if(Result < 0){
        print("WHvGetCapability(WHvCapabilityCodeHypervisorPresent) failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    if(!HypervisorPresent){
        print("Error: Windows Hypervisor Platform reported that no hypervisor is present.\n");
        print("       This might mean you simply have to enable the Windows Hypervisor Platform\n");
        print("       optional Windows feature. For more information see the \"Build\" section\n");
        print("       of the Readme.\n");
        os_panic(1);
    }
    
    // 
    // Get the 'ProcessorFeatures' so we can enabled all of them for the guest. 
    // The only non-default features we really care about are about speculation control. 
    // The guest expectes them to be enabled and otherwise some MSRs (e.g.: IA32_SPEC_CTRL on Intel) #GP.
    // 
    u64 ProcessorFeatures = 0;
    Result = WHvGetCapability(/*WHvCapabilityCodeProcessorFeatures*/0x1001, &ProcessorFeatures, sizeof(ProcessorFeatures), &BytesWritten);
    if(Result < 0){
        print("[WHvGetCapability(WHvCapabilityCodeFeatures)] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    // 
    // Create a Partition, which is the Microsoft name for Virtual or non-Virtual machine.
    // 
    Result = WHvCreatePartition(&Partition);
    if(Result < 0){
        print("[WHvCreatePartition] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    // 
    // We would really like to disable rdrand and rdseed here.
    // There are slots in the 'WHvPartitionPropertyCodeProcessorFeatures' for rdrand and rdseed.
    // Sadly, these slot don't seem to actually impact the processor. Maybe they alter whats in CPUID?
    // 
    //                                                                          - Pascal Beyer 24.02.2023
    
    Result = WHvSetPartitionProperty(Partition, /*WHvPartitionPropertyCodeProcessorFeatures*/0x00001001, &ProcessorFeatures, sizeof(ProcessorFeatures));
    if(Result < 0){
        print("[WHvSetPartitionProperty(WHvPartitionPropertyCodeProcessorFeatures)] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    // 
    // Set the processor count to 1.
    // 
    Result = WHvSetPartitionProperty(Partition, /*WHvPartitionPropertyCodeProcessorCount*/0x1fff, &(u64){2}, 8);
    if(Result < 0){
        print("[WHvSetPartitionProperty(WHvPartitionPropertyCodeProcessorCount)] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    // 
    // We want to exit on most events.
    // Note that most of these options only enable exiting on unhandled events.
    // 
    
    u64 ExtendedVmExits = /*X64CpuidExit*/1 | /*X64MsrExit*/2 | /*ExceptionExit*/4  | /*HypercallExit*/32;
    if(HYPERVISOR_EXIT_ON_RDTSC) ExtendedVmExits |= /*X64RdtscExit*/8;
    
    Result = WHvSetPartitionProperty(Partition, /*WHvPartitionPropertyCodeExtendedVmExits*/1, &ExtendedVmExits, sizeof(ExtendedVmExits));
    if(Result < 0){
        print("[WHvSetPartitionProperty(WHvPartitionPropertyCodeExtendedVmExits)] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    // 
    // Exit on any access to a Model Specific Register which Microsoft feels like giving us access to.
    // For us the 'Tsc' ones are important to get more determinism.
    // 
    // @cleanup: Potentially, we should query and then set whatever the query gives back, instead of just setting these random bit which are currently defined.
    // 
    // @note: For now I am not exiting on msr reads which I cannot query or change (IA32_MISC_ENABLE being the main culprit).
    // 
    u64 MsrExitBitmap = /*UnhandledMsrs*/1 | /*TscMsrWrite*/2 | /*TscMsrRead*/4 | /*ApicBaseMsrWrite*/8;
    Result = WHvSetPartitionProperty(Partition, /*WHvPartitionPropertyCodeX64MsrExitBitmap*/5, &MsrExitBitmap, sizeof(MsrExitBitmap));
    if(Result < 0){
        print("[WHvSetPartitionProperty(MsrExitBitmap)] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    // 
    // Enable Local Apic Emulation, this allows us to call:
    //     WHvRequestInterrupt
    //     WHvGetVirtualProcessorInterruptControllerState2
    //     WHvSetVirtualProcessorInterruptControllerState2
    // I am not sure what this actually means. Is there a way for a processor to run without an Apic?
    // Maybe for a _user-mode_ hypervisor?
    // 
    Result = WHvSetPartitionProperty(Partition, /*WHvPartitionPropertyCodeLocalApicEmulationMode*/0x00001005, &(u32){/*WHvX64LocalApicEmulationModeXApic*/1}, 4);
    if(Result < 0){
        print("[WHvSetPartitionProperty(WHvPartitionPropertyCodeLocalApicEmulationMode)] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    // 
    // Setup the Partition. 
    // This means that we cannot change certain partition properties anymore.
    // 
    Result = WHvSetupPartition(Partition);
    if(Result < 0){
        print("[WHvSetupPartition] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    Result = WHvCreateVirtualProcessor(Partition, /*VirtualProcessorIndex*/0, /*Flags (unused must be 0)*/0);
    if(Result < 0){
        print("[WHvCreateVirtualProcessor] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    Result = WHvCreateVirtualProcessor(Partition, /*VirtualProcessorIndex*/1, /*Flags (unused must be 0)*/0);
    if(Result < 0){
        print("[WHvCreateVirtualProcessor] failed with result 0x%x\n", Result);
        os_panic(1);
    }
    
    assert(globals.snapshot.physical_memory);
    {
        u32 Flags = /*WHvMapGpaRangeFlagRead*/1 | /*WHvMapGpaRangeFlagWrite*/2 | /*WHvMapGpaRangeFlagExecute*/4;
        
        u8 *base = globals.snapshot.physical_memory;
        u64 size = globals.snapshot.physical_memory_size;
        
        u64 guest_base = 0;
        
        Result = WHvMapGpaRange(Partition, base, guest_base, size, Flags);
        if(Result < 0){
            print("[WHvMapGpaRange] failed with result 0x%x\n", Result);
            os_panic(1);
        }
        
        Result = WHvMapGpaRange(Partition, frame_buffer, 0xFFF800000, sizeof(frame_buffer), Flags);
        if(Result < 0){
            print("[WHvMapGpaRange] failed with result 0x%x\n", Result);
            os_panic(1);
        }
        
        Result = WHvMapGpaRange(Partition, frame_buffer, 0xF8000000, sizeof(frame_buffer), Flags);
        if(Result < 0){
            print("[WHvMapGpaRange] failed with result 0x%x\n", Result);
            os_panic(1);
        }
    }
    
    // Unmap the I/O-Apic so we get a memory-access vm-exit, when trying to access it.
    // Then, we can handle the I/O-Apic read/write from there.
    WHvUnmapGpaRange(Partition, 0xfec00000, 0x1000);
    
    if(globals.vmbus.monitor_page1){
        WHvUnmapGpaRange(Partition, globals.vmbus.monitor_page1, 0x1000);
    }
    
    if(globals.vmbus.monitor_page2){
        WHvUnmapGpaRange(Partition, globals.vmbus.monitor_page2, 0x1000);
    }
    
    globals.debugger_event = CreateEventA(null, 0, 0, null);
    
    return Partition;
}

void hypervisor_perform_end_of_interrupt(struct context *context){
    
    // 
    // @cleanup: I am doing a manual End of Interrupt (EOI) here (clearing the highest set bit of the 'in service register' in the local apic).
    //           It seems like there is probably a way to tell WHv to do this for me?
    // 
    
    struct serialized_local_apic local_apic = {0};
    
    u32 size_written;
    s32 Result = WHvGetVirtualProcessorInterruptControllerState2(globals.Partition, context->processor_index, &local_apic, sizeof(local_apic), &size_written);
    if(Result < 0 || size_written != sizeof(local_apic)){
        print("[WHvGetVirtualProcessorInterruptControllerState2] %x %x %x\n", Result, size_written, sizeof(local_apic));
        os_panic(1);
    }
    
    for(s32 bit_index = 255; bit_index >= 0; bit_index--){
        s32 dword_index = bit_index / 32;
        s32 bit = (1u << bit_index % 32);
        
        if(local_apic.in_service_register[dword_index][0] & bit){
            local_apic.in_service_register[dword_index][0] &= ~bit;
            break;
        }
    }
    
    Result = WHvSetVirtualProcessorInterruptControllerState2(globals.Partition, context->processor_index, &local_apic, sizeof(local_apic));
    if(Result < 0 || size_written != sizeof(local_apic)){
        print("[WHvSetVirtualProcessorInterruptControllerState2] %x\n", Result);
        os_panic(1);
    }
}

void update_exception_exit_bitmap(void){
    // 
    // When we are single stepping, we have to exit on most exceptions,
    // otherwise, the single step would not follow into the exception vector.
    // 
    // If we are not single stepping, we only really care about breakpoint, 
    // i.e. `WHvX64ExceptionTypeDebugTrapOrFault`.
    // 
    // This reduces the amount of VMEXITs we have to perform by a lot.
    // 
    u64 ExceptionBitmapSingleStepping = 
            (1ull << /*WHvX64ExceptionTypeDivideErrorFault*/             0x0) |
            (1ull << /*WHvX64ExceptionTypeDebugTrapOrFault*/             0x1) |
            // (1ull << /*WHvX64ExceptionTypeBreakpointTrap*/               0x3) |
            (1ull << /*WHvX64ExceptionTypeOverflowTrap*/                 0x4) |
            (1ull << /*WHvX64ExceptionTypeBoundRangeFault*/              0x5) |
            (1ull << /*WHvX64ExceptionTypeInvalidOpcodeFault*/           0x6) |
            (1ull << /*WHvX64ExceptionTypeDeviceNotAvailableFault*/      0x7) |
            (1ull << /*WHvX64ExceptionTypeDoubleFaultAbort*/             0x8) |
            (1ull << /*WHvX64ExceptionTypeInvalidTaskStateSegmentFault*/ 0xa) |
            (1ull << /*WHvX64ExceptionTypeSegmentNotPresentFault*/       0xb) |
            (1ull << /*WHvX64ExceptionTypeStackFault*/                   0xc) |
            (1ull << /*WHvX64ExceptionTypeGeneralProtectionFault*/       0xd) |
            (1ull << /*WHvX64ExceptionTypePageFault*/                    0xe) |
            (1ull << /*WHvX64ExceptionTypeFloatingPointErrorFault*/      0x10)|
            (1ull << /*WHvX64ExceptionTypeAlignmentCheckFault*/          0x11)|
            (1ull << /*WHvX64ExceptionTypeMachineCheckAbort*/            0x12)|
            (1ull << /*WHvX64ExceptionTypeSimdFloatingPointFault*/       0x13);
    
    u64 ExceptionBitmap = globals.single_stepping ? ExceptionBitmapSingleStepping : (1ull << /*WHvX64ExceptionTypeDebugTrapOrFault*/0x1);
    
    s32 Result = WHvSetPartitionProperty(globals.Partition, /*WHvPartitionPropertyCodeExceptionExitBitmap*/2, &ExceptionBitmap, sizeof(ExceptionBitmap));
    if(Result < 0){
        print("[WHvSetPartitionProperty(WHvPartitionPropertyCodeExceptionExitBitmap)] failed with result 0x%x\n", Result);
        os_panic(1);
    }
}

void hyperv_apply_local_apic_state(struct context *context){
    
    // 
    // Synchronize the local apic state.
    // 
    
    struct registers *registers = &context->registers;
    struct serialized_local_apic local_apic = {0};
    
    u32 size_written;
    s32 Result = WHvGetVirtualProcessorInterruptControllerState2(globals.Partition, context->processor_index, &local_apic, sizeof(local_apic), &size_written);
    if(Result < 0 || size_written != sizeof(local_apic)){
        print("[WHvGetVirtualProcessorInterruptControllerState2] %x %x %x\n", Result, size_written, sizeof(local_apic));
        os_panic(1);
    }
    
    local_apic.id_register[0] = registers->local_apic.id_register;
    local_apic.version_register[0] = registers->local_apic.version_register;
    
    // local_apic.task_priority_register[0] = registers->local_apic.task_priority_register;
    local_apic.task_priority_register[0] = (u32)(context->registers.cr8 & 0xf) << 4;
    local_apic.arbitration_priority_register[0] = registers->local_apic.arbitration_priority_register;
    local_apic.processor_priority_register[0] = registers->local_apic.processor_priority_register;
    local_apic.end_of_interrupt_register[0] = registers->local_apic.end_of_interrupt_register;
    local_apic.remote_read_register[0] = registers->local_apic.remote_read_register;
    local_apic.local_destination_register[0] = registers->local_apic.local_destination_register;
    local_apic.destination_format_register[0] = registers->local_apic.destination_format_register;
    local_apic.spurious_interrupt_vector_register[0] = registers->local_apic.spurious_interrupt_vector_register;
    
    for(u32 index = 0; index < 8; index++){
        local_apic.in_service_register[index][0] = registers->local_apic.in_service_register[index];
        local_apic.trigger_mode_register[index][0] = registers->local_apic.trigger_mode_register[index];
        local_apic.interrupt_request_register[index][0] = registers->local_apic.interrupt_request_register[index];
    }
    
    local_apic.error_status_register[0] = registers->local_apic.error_status_register;
    
    local_apic.interrupt_command_register_0_31[0] = registers->local_apic.interrupt_command_register.low;
    local_apic.interrupt_command_register_32_63[0] = registers->local_apic.interrupt_command_register.high;
    
    local_apic.local_vector_table_corrected_machine_check_interrupt_register[0] = registers->local_apic.local_vector_table.corrected_machine_check_interrupt_register;
    local_apic.local_vector_table_timer_register[0] = registers->local_apic.local_vector_table.timer_register;
    local_apic.local_vector_table_thermal_sensor_register[0] = registers->local_apic.local_vector_table.thermal_sensor_register;
    local_apic.local_vector_table_performance_monitoring_counters_register[0] = registers->local_apic.local_vector_table.performance_monitoring_counters_register;
    local_apic.local_vector_table_lint0_register[0] = registers->local_apic.local_vector_table.lint0_register;
    local_apic.local_vector_table_lint1_register[0] = registers->local_apic.local_vector_table.lint1_register;
    local_apic.local_vector_table_error_register[0] = registers->local_apic.local_vector_table.error_register;
    
    local_apic.timer_initial_count_register[0] = registers->local_apic.timer_initial_count_register;
    local_apic.timer_current_count_register[0] = registers->local_apic.timer_current_count_register;
    
    local_apic.timer_divide_configuration_register[0] = registers->local_apic.timer_divide_configuration_register;
    
    Result = WHvSetVirtualProcessorInterruptControllerState2(globals.Partition, context->processor_index, &local_apic, sizeof(local_apic));
    if(Result < 0 || size_written != sizeof(local_apic)){
        print("[WHvSetVirtualProcessorInterruptControllerState2] %x\n", Result);
        os_panic(1);
    }
}

void start_execution_hypervisor(struct context *context){
    
    HANDLE Partition = globals.Partition;
    
    context->use_hypervisor = 1;
    
    set_next_timer_interrupt_time(context, &context->registers);
    
    struct registers *registers = &context->registers;
    
    context->crash = CRASH_none;
    context->crash_address = 0;
    
    // Setting this value makes sure we won't use the translation look aside buffers.
    // This in turn means, we don't have to invalidate them each time we exit the hypervisor.
    context->skip_setting_permission_bits = 1;
    
    static u32 RegisterNames[] = {
        /*WHvX64RegisterRax*/ 0x00000000,
        /*WHvX64RegisterRcx*/ 0x00000001,
        /*WHvX64RegisterRdx*/ 0x00000002,
        /*WHvX64RegisterRbx*/ 0x00000003,
        /*WHvX64RegisterRsp*/ 0x00000004,
        /*WHvX64RegisterRbp*/ 0x00000005,
        /*WHvX64RegisterRsi*/ 0x00000006,
        /*WHvX64RegisterRdi*/ 0x00000007,
        /*WHvX64RegisterR8*/  0x00000008,
        /*WHvX64RegisterR9*/  0x00000009,
        /*WHvX64RegisterR10*/ 0x0000000A,
        /*WHvX64RegisterR11*/ 0x0000000B,
        /*WHvX64RegisterR12*/ 0x0000000C,
        /*WHvX64RegisterR13*/ 0x0000000D,
        /*WHvX64RegisterR14*/ 0x0000000E,
        /*WHvX64RegisterR15*/ 0x0000000F,
        
        /*WHvX64RegisterRip*/    0x00000010,
        /*WHvX64RegisterRflags*/ 0x00000011,
        
        /*WHvX64RegisterEs*/ 0x00000012, // Selector in .DMP, rest in the GDT.
        /*WHvX64RegisterCs*/ 0x00000013, // Selector in .DMP, rest in the GDT.
        /*WHvX64RegisterSs*/ 0x00000014, // Selector in .DMP, rest in the GDT.
        /*WHvX64RegisterDs*/ 0x00000015, // Selector in .DMP, rest in the GDT.
        
        /*WHvX64RegisterFs*/ 0x00000016, // Selector in .DMP, rest in the GDT.
        /*WHvX64RegisterGs*/ 0x00000017, // Selector in .DMP, rest in the GDT.
        
        /*WHvX64RegisterLdtr*/ 0x00000018, // Local Descriptor Table Register     (Selector in _KDDEBUGGER_DATA64, rest in the GDT).
        /*WHvX64RegisterTr*/   0x00000019, // Tast Register (Points to the TSS)   (Selector in _KDDEBUGGER_DATA64, rest in the GDT).
        
        /*WHvX64RegisterIdtr*/ 0x0000001A, // Interrupt Descriptor Table Register (in _KPCR).
        /*WHvX64RegisterGdtr*/ 0x0000001B, // Global Descriptor Table Register    (in _KPCR).
        
        /*WHvX64RegisterCr0*/ 0x0000001C,
        /*WHvX64RegisterCr2*/ 0x0000001D,
        /*WHvX64RegisterCr3*/ 0x0000001E,
        /*WHvX64RegisterCr4*/ 0x0000001F,
        /*WHvX64RegisterCr8*/ 0x00000020,
        
        /*WHvX64RegisterDr0*/ 0x00000021,
        /*WHvX64RegisterDr1*/ 0x00000022,
        /*WHvX64RegisterDr2*/ 0x00000023,
        /*WHvX64RegisterDr3*/ 0x00000024,
        /*WHvX64RegisterDr6*/ 0x00000025,
        /*WHvX64RegisterDr7*/ 0x00000026,
        
        /*WHvX64RegisterXCr0*/ 0x00000027,
        
        /*WHvX64RegisterEfer*/          0x00002001,
        /*WHvX64RegisterKernelGsBase*/  0x00002002, //
        /*WHvX64RegisterApicBase*/      0x00002003, // nt!HalpLocalApicPhysical | 0x900 (enabled + boot strap processor)
        /*WHvX64RegisterPat*/           0x00002004, // Page Attribute Table - msr[277] = 00070106`00070106 (?)
        /*WHvX64RegisterStar*/          0x00002008,
        /*WHvX64RegisterLstar*/         0x00002009, // nt!KiSystemCall64
        /*WHvX64RegisterCstar*/         0x0000200A, // nt!KiSystemCall32
        /*WHvX64RegisterSfmask*/        0x0000200B, // msr[c0000084] = 00000000`00004700
        /*WHvX64RegisterTscAux*/        0x0000207B, // 0
        
        /*WHvX64RegisterMsrMtrrDefType*/    0x0000200E,
        
        /*WHvX64RegisterMsrMtrrFix64k00000*/ 0x00002070,
        /*WHvX64RegisterMsrMtrrFix16k80000*/ 0x00002071,
        
        /*WHvX64RegisterMsrMtrrPhysBase0*/  0x00002010,
        /*WHvX64RegisterMsrMtrrPhysMask0*/  0x00002040,
        
        // /*WHvX64RegisterMsrMtrrCap*/ 0x0000200D, This cannot be altered, hence we do not set it.

        /*WHvX64RegisterTsc*/           0x00002000, // We don't set this anymore @test @cleanup: explain (smp)
    };
    
    static u32 IntelSpecificRegisterNames[] = {
        /*WHvX64RegisterSpecCtrl*/      0x00002084, // IA32_SPEC_CTRL
    };
    struct whv_register_value IntelSpecificRegisterValues[array_count(IntelSpecificRegisterNames)];
    
    // @note: We fix up the descriptors here as the jit does not care about anything but the selector.
    registers->cs = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->cs.selector);
    registers->ss = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->ss.selector);
    registers->ds = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->ds.selector);
    registers->es = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->es.selector);
    
    registers->fs = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->fs.selector);
    registers->gs = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->gs.selector);
    registers->gs.base = registers->gs_base;
    registers->fs.base = registers->fs_base;
    
    u32 xsave_area_size = 0; 
    WHvGetVirtualProcessorXsaveState(Partition, /*VpIndex*/0, null, 0, &xsave_area_size);
    if(xsave_area_size > sizeof(struct xsave_area)){
        print("This computer reports a bigger xsave area size than currently supported. (0x%x vs 0x%x)\n", xsave_area_size, sizeof(struct xsave_area));
        os_panic(1);
    }
    
    registers->dr7 |= (1 << 13); // General Detect Enable. Causes a debug Exception on any attempt at accessing dr0-dr7.
    registers->dr6 &= ~(1 << 13); // Clear the Debug register Access detected bit.
    registers->dr6 &= ~0xf; // Clear the "Condition Detected" bits.
    
    if(globals.single_stepping){
        // If we are starting by 'single stepping', it means we want to enter the debugger on the first instruction.
        // Hence, we put a breakpoint on the instruction we are currently at.
        hypervisor_set_breakpoint(context, registers, BREAKPOINT_execute, BREAKPOINT_FLAG_oneshot, registers->rip, 1, (struct string){0});
        update_exception_exit_bitmap();
    }
    
    u32 virtual_processor_index = context->processor_index;
    
    if(virtual_processor_index){
        u32 WHvRegisterInternalActivityState = /*WHvRegisterInternalActivityState*/0x80000005;
        struct whv_register_value value = {0};
        int Result = WHvSetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &WHvRegisterInternalActivityState, 1, &value);
        if(Result < 0){
            print("[WHvSetVirtualProcessorRegisters] Unsetting HvRegisterExplicitSuspend failed with result 0x%x\n", Result);
            _exit(1);
        }
    }else{
        // 
        // Need to update the exception bitmap even if not single_stepping to ensure the General Detect Enable stuff works. This took me long to debug.
        // 
        update_exception_exit_bitmap();
    }
    
    while(true){
        
        //
        // Setup the register state:
        //
        struct whv_register_value RegisterValues[] = {
            {registers->rax},
            {registers->rcx},
            {registers->rdx},
            {registers->rbx},
            {registers->rsp},
            {registers->rbp},
            {registers->rsi},
            {registers->rdi},
            {registers->r8},
            {registers->r9},
            {registers->r10},
            {registers->r11},
            {registers->r12},
            {registers->r13},
            {registers->r14},
            {registers->r15},
            
            {registers->rip},
            {registers->rflags},
            
            {.segment = registers->es},
            {.segment = registers->cs},
            {.segment = registers->ss},
            {.segment = registers->ds},
            
            {.segment = registers->fs},
            {.segment = registers->gs},
            
            {.segment = registers->ldt},
            {.segment = registers->tr},
            
            {.global_segment = {.Base = registers->idt_base, .Limit = registers->idt_limit}},
            {.global_segment = {.Base = registers->gdt_base, .Limit = registers->gdt_limit}},
            
            {registers->cr0},
            {registers->cr2},
            {registers->cr3},
            {registers->cr4},
            {registers->cr8},
            
            {registers->dr0},
            {registers->dr1},
            {registers->dr2},
            {registers->dr3},
            {registers->dr6},
            {registers->dr7},
            
            {registers->xcr0},
            
            {registers->ia32_efer},
            {registers->gs_swap},
            {registers->ia32_apic_base},
            {registers->ia32_pat},
            {registers->ia32_star},
            {registers->ia32_lstar},
            {registers->ia32_cstar},
            {registers->ia32_fmask},
            {registers->ia32_tsc_aux},
            
            // note: {registers->ia32_mtrr_cap} cannot be altered, but it is already correct at 0x508.
            {registers->ia32_mtrr_def_type},
            
            {/*MTRR_FIX_64K_00000*/0x0606060606060606},
            {/*MTRR_FIX_16K_80000*/0x0606060606060606},
            
            {registers->ia32_mtrr_phys_base},
            {registers->ia32_mtrr_phys_mask},
            
            {/*ia32_tsc*/0}, // We don't set this anymore because of smp
        };
        
        static_assert(array_count(RegisterValues) == array_count(RegisterNames));
        
        s32 Result = WHvSetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &RegisterNames[0], array_count(RegisterNames)-1, &RegisterValues[0]);
        if(Result < 0){
            print("[WHvSetVirtualProcessorRegisters] failed with result 0x%x\n", Result);
            os_panic(1);
        }
        
        if(globals.cpu_vendor == VENDOR_INTEL){
            
            u64 IntelSpecificRegisterIndex = 0;
            
            IntelSpecificRegisterValues[IntelSpecificRegisterIndex++] = (struct whv_register_value){registers->ia32_spec_ctrl};
            
            assert(IntelSpecificRegisterIndex == array_count(IntelSpecificRegisterValues));
            
            Result = WHvSetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &IntelSpecificRegisterNames[0], array_count(IntelSpecificRegisterNames), &IntelSpecificRegisterValues[0]);
            if(Result < 0){
                print("[WHvSetVirtualProcessorRegisters (intel-specific)] failed with result 0x%x\n", Result);
                os_panic(1);
            }
        }
        
        //
        // Load the Xsave area (aka the floating point registers).
        //
        struct xsave_area xsave_area = xsave_area_from_registers(registers);
        
        Result = WHvSetVirtualProcessorXsaveState(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &xsave_area, xsave_area_size);
        if(Result < 0){
            print("[WHvSetVirtualProcessorXsaveState] failed with result 0x%x\n", Result);
            os_panic(1);
        }
        
        // @cleanup: auto-eoi.
        hyperv_apply_local_apic_state(context);
        
        struct{
            u32 ExitReason;
            u32 Reserved;
            
            struct {
                struct{
                    u16 Cpl   : 2;
                    u16 Cr0Pe : 1;
                    u16 Cr0Am : 1;
                    u16 EferLma : 1;
                    u16 DebugActive : 1;
                    u16 InterruptionPending : 1;
                    u16 Reserved0 : 5;
                    u16 InterruptShadow     : 1;
                    u16 Reserved1 : 3;
                } ExecutionState;
                
                u8  InstructionLength : 4;
                u8  Cr8 : 4;
                u8  Reserved;
                u32 Reserved2;
                struct segment Cs;
                u64 Rip;
                u64 Rflags;
            } VpContext;
            
            u8 ExitData[0x200];
        } ExitContext;
        
        
        // 
        // Run until we encounter an event we don't have a fast path for.
        // 
        while(true){
            
            Result = WHvRunVirtualProcessor(Partition, virtual_processor_index, &ExitContext, sizeof(ExitContext));
            if(Result < 0){
                print("[WHvRunVirtualProcessor] failed with Result 0x%x\n", Result);
                os_panic(1);
            }
            
            if(ExitContext.ExitReason != /*WHvRunVpExitReasonX64MsrAccess*/0x1000) break;
            
            // 
            // Fast path for frequently used MSRs.
            // 
            
            struct{
                struct{
                    u32 IsWrite  : 1;
                    u32 Reserved : 31;
                } AccessInfo;
                u32 MsrNumber;
                u64 Rax;
                u64 Rdx;
            } *MsrAccess = (void *)ExitContext.ExitData;
            
            if(!MsrAccess->AccessInfo.IsWrite) break;
            
            if(MsrAccess->MsrNumber == HV_X64_MSR_ICR){
                union{
                    u64 command;
                    struct{
                        u64 vector_number    : 8; // bits 0-7
                        u64 interrupt_type   : 3; // bits 8-11    0 normal, 1 lowest priority, 2 MSI, 4 NMI, 5 INIT, 6 SIPI
                        u64 destination_mode : 1; // bit  12      0 physical, 1 logical
                        u64 delivery_status  : 1; // bit  13
                        u64 reserved         : 1; // bit  14 
                        u64 level            : 1; // bit  15
                        u64 trigger_mode     : 1; // bit  16
                        u64                  : 2; // bit  17-18
                        u64 destination_type : 2; // bit  19-20   0 destination is local apic id, 1 self, 2 broadcast, 3 broadcast not including self.
                        u64                  : 12;
                        
                        u64             : 24;
                        u64 destination : 8;
                    };
                } ICR = {
                    .command = (MsrAccess->Rdx << 32) | (u32)MsrAccess->Rax,
                };
                
                if(PRINT_INTERRUPT_EVENTS){
                    print("[%d] ICR:\n", registers->local_apic.id_register);
                    print("    vector_number %x\n", ICR.vector_number);
                    print("    interrupt_type %x\n", ICR.interrupt_type);
                    print("    destination_mode %x\n", ICR.destination_mode);
                    print("    delivery_status %x\n", ICR.delivery_status);
                    print("    level %x\n", ICR.level);
                    print("    trigger_mode %x\n", ICR.trigger_mode);
                    print("    destination_type %x\n", ICR.destination_type);
                    print("    destination %x\n", ICR.destination);
                }
                
                if(ICR.destination_mode == /*Physical*/0){
                    int deliver = 0;
                    int queue   = 0;
                    
                    if(ICR.destination_type == 0){
                        if(ICR.destination == registers->local_apic.id_register){
                            deliver = 1;
                        }else{
                            queue   = 1;
                        }
                    }else if(ICR.destination_type == /*self*/1){
                        deliver = 1;
                    }else if(ICR.destination_type == /*broadcast*/2){
                        deliver = 1;
                        queue   = 1;
                    }else if(ICR.destination_type == /*broadcast not self*/3){
                        queue = 1;
                    }
                    
                    if(deliver){
                        struct interrupt_control interrupt_control = {
                            .Type            = ICR.interrupt_type,
                            .DestinationMode = /*physical*/0,
                            .TriggerMode     = ICR.trigger_mode,
                            .Destination     = registers->local_apic.id_register,
                            .Vector          = (u32)ICR.vector_number,
                        };
                        
                        Result = WHvRequestInterrupt(Partition, &interrupt_control, sizeof(interrupt_control));
                        if(Result < 0){
                            print("[WHvRequestInterrupt] Failed with code 0x%x\n", Result);
                            os_panic(1);
                        }
                    }
                    
                    if(globals.second_thread_context){
                        struct context *other = context == globals.second_thread_context ? globals.main_thread_context : globals.second_thread_context;
                        
                        struct pending_interrupt *pending_interrupt = &other->pending_interrupts[other->pending_interrupt_reserved % array_count(other->pending_interrupts)];
                        pending_interrupt->vector_number    = (u8)ICR.vector_number;
                        pending_interrupt->destination      = (u8)ICR.destination;
                        pending_interrupt->target_vtl       = (u8)context->registers.vtl_state.current_vtl;
                        pending_interrupt->destination_mode = (u8)ICR.destination_mode;
                        other->pending_interrupt_reserved++;
                        
                        s32 CancelResult = WHvCancelRunVirtualProcessor(Partition, /*virtual processor index*/other->processor_index, /*Flags (must be zero)*/0);
                        if(CancelResult) print("CancelResult %x\n", CancelResult);
                    }
                }else{
                    assert(ICR.destination_type == 0); // Not sure if this means anything for logical interrupts.
                    
                    if(ICR.destination & (registers->local_apic.local_destination_register>>24)){
                        struct interrupt_control interrupt_control = {
                            .Type            = ICR.interrupt_type,
                            .DestinationMode = /*Physical*/0,
                            .TriggerMode     = ICR.trigger_mode,
                            .Destination     = registers->local_apic.id_register,
                            .Vector          = (u32)ICR.vector_number,
                        };
                        
                        Result = WHvRequestInterrupt(Partition, &interrupt_control, sizeof(interrupt_control));
                        if(Result < 0){
                            print("[WHvRequestInterrupt] Failed with code 0x%x\n", Result);
                            os_panic(1);
                        }
                    }
                    
                    if(globals.second_thread_context){
                        struct context *other = context == globals.second_thread_context ? globals.main_thread_context : globals.second_thread_context;
                        
                        struct pending_interrupt *pending_interrupt = &other->pending_interrupts[other->pending_interrupt_reserved % array_count(other->pending_interrupts)];
                        pending_interrupt->vector_number    = (u8)ICR.vector_number;
                        pending_interrupt->destination      = (u8)ICR.destination;
                        pending_interrupt->target_vtl       = (u8)context->registers.vtl_state.current_vtl;
                        pending_interrupt->destination_mode = (u8)ICR.destination_mode;
                        
                        other->pending_interrupt_reserved++;
                        
                        s32 CancelResult = WHvCancelRunVirtualProcessor(Partition, /*virtual processor index*/other->processor_index, /*Flags (must be zero)*/0);
                        if(CancelResult) print("CancelResult %x\n", CancelResult);
                    }
                }
            }else if(MsrAccess->MsrNumber == HV_X64_MSR_EOI){
                hypervisor_perform_end_of_interrupt(context);
            }else{
                break;
            }
            
            struct whv_register_value next_rip = {ExitContext.VpContext.Rip + ExitContext.VpContext.InstructionLength};
            
            Result = WHvSetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &(u32){/*WHvX64RegisterRip*/0x00000010}, 1, &next_rip);
            if(Result < 0){
                print("[WHvSetVirtualProcessorRegisters] Could not set rip.\n");
            }
        }
        
        {
            //
            // Get the register state and update 'registers'.
            //
            
            Result = WHvGetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, RegisterNames, array_count(RegisterNames), RegisterValues);
            if(Result < 0){
                print("[WHvGetVirtualProcessorRegisters] Returned with Result 0x%x\n", Result);
                os_panic(1);
            }
            
            u32 RegisterIndex = 0;
            
            registers->rax = RegisterValues[RegisterIndex++].reg64;
            registers->rcx = RegisterValues[RegisterIndex++].reg64;
            registers->rdx = RegisterValues[RegisterIndex++].reg64;
            registers->rbx = RegisterValues[RegisterIndex++].reg64;
            registers->rsp = RegisterValues[RegisterIndex++].reg64;
            registers->rbp = RegisterValues[RegisterIndex++].reg64;
            registers->rsi = RegisterValues[RegisterIndex++].reg64;
            registers->rdi = RegisterValues[RegisterIndex++].reg64;
            registers->r8  = RegisterValues[RegisterIndex++].reg64;
            registers->r9  = RegisterValues[RegisterIndex++].reg64;
            registers->r10 = RegisterValues[RegisterIndex++].reg64;
            registers->r11 = RegisterValues[RegisterIndex++].reg64;
            registers->r12 = RegisterValues[RegisterIndex++].reg64;
            registers->r13 = RegisterValues[RegisterIndex++].reg64;
            registers->r14 = RegisterValues[RegisterIndex++].reg64;
            registers->r15 = RegisterValues[RegisterIndex++].reg64;
            
            registers->rip    = RegisterValues[RegisterIndex++].reg64;
            registers->rflags = RegisterValues[RegisterIndex++].reg64;
            
            registers->es = RegisterValues[RegisterIndex++].segment;
            registers->cs = RegisterValues[RegisterIndex++].segment;
            registers->ss = RegisterValues[RegisterIndex++].segment;
            registers->ds = RegisterValues[RegisterIndex++].segment;
            
            registers->fs = RegisterValues[RegisterIndex++].segment;
            registers->gs = RegisterValues[RegisterIndex++].segment;
            registers->gs_base = registers->gs.base;
            registers->fs_base = registers->fs.base;
            
            registers->ldt = RegisterValues[RegisterIndex++].segment;
            registers->tr  = RegisterValues[RegisterIndex++].segment;
            
            if(RegisterValues[RegisterIndex].global_segment.Base != 0){
                // Disgusting hack for secure kernel patch-guard zeroing out the idt.
                registers->idt_base  = RegisterValues[RegisterIndex].global_segment.Base;
                registers->idt_limit = RegisterValues[RegisterIndex].global_segment.Limit;
            }
            RegisterIndex++;
            
            registers->gdt_base  = RegisterValues[RegisterIndex].global_segment.Base;
            registers->gdt_limit = RegisterValues[RegisterIndex].global_segment.Limit;
            RegisterIndex++;
            
            registers->cr0 = RegisterValues[RegisterIndex++].reg64;
            registers->cr2 = RegisterValues[RegisterIndex++].reg64;
            registers->cr3 = RegisterValues[RegisterIndex++].reg64;
            registers->cr4 = RegisterValues[RegisterIndex++].reg64;
            registers->cr8 = RegisterValues[RegisterIndex++].reg64;
            
            registers->dr0 = RegisterValues[RegisterIndex++].reg64;
            registers->dr1 = RegisterValues[RegisterIndex++].reg64;
            registers->dr2 = RegisterValues[RegisterIndex++].reg64;
            registers->dr3 = RegisterValues[RegisterIndex++].reg64;
            registers->dr6 = RegisterValues[RegisterIndex++].reg64;
            registers->dr7 = RegisterValues[RegisterIndex++].reg64;
            
            registers->xcr0 = RegisterValues[RegisterIndex++].reg64;
            
            registers->ia32_efer      = RegisterValues[RegisterIndex++].reg64;
            registers->gs_swap        = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_apic_base = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_pat       = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_star      = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_lstar     = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_cstar     = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_fmask     = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_tsc_aux   = RegisterValues[RegisterIndex++].reg64;
            
            registers->ia32_mtrr_def_type = RegisterValues[RegisterIndex++].reg64;
            RegisterIndex++;// registers->ia32_mtrr_fix64k00000 = RegisterValues[RegisterIndex++].reg64;
            RegisterIndex++;// registers->ia32_mtrr_fix16k80000 = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_mtrr_phys_base = RegisterValues[RegisterIndex++].reg64;
            registers->ia32_mtrr_phys_mask = RegisterValues[RegisterIndex++].reg64;
            
            if(!HYPERVISOR_EXIT_ON_RDTSC){
                registers->ia32_tsc = RegisterValues[RegisterIndex++].reg64;
            }else{
                RegisterIndex++;
            }
            
            assert(RegisterIndex == array_count(RegisterNames));
            
            if(globals.cpu_vendor == VENDOR_INTEL){
                
                Result = WHvGetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, IntelSpecificRegisterNames, array_count(IntelSpecificRegisterNames), IntelSpecificRegisterValues);
                if(Result < 0){
                    print("[WHvGetVirtualProcessorRegisters] Returned with Result 0x%x\n", Result);
                    os_panic(1);
                }
                
                u32 IntelSpecificRegisterIndex = 0;
                
                registers->ia32_spec_ctrl = IntelSpecificRegisterValues[IntelSpecificRegisterIndex++].reg64;
                
                assert(IntelSpecificRegisterIndex == array_count(IntelSpecificRegisterValues));
            }
            
            u32 BytesWritten = 0;
            
            Result = WHvGetVirtualProcessorXsaveState(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &xsave_area, xsave_area_size, &BytesWritten);
            if(Result < 0){
                print("[WHvGetVirtualProcessorXsaveState] failed with result 0x%x\n", Result);
                os_panic(1);
            }
            
            if(BytesWritten != xsave_area_size){
                print("[WHvGetVirtualProcessorXsaveState] wrote %x bytes, %x were expected\n", BytesWritten, xsave_area_size);
                os_panic(1);
            }
            
            load_xsave_registers(registers, xsave_area);
            
            {
                struct whv_register_value fp_control = {0};
                Result = WHvGetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &(u32){/*WHvX64RegisterFpControlStatus*/0x00001018}, 1, &fp_control);
                if(Result < 0){
                    print("[WHvGetVirtualProcessorRegisters] Returned with Result 0x%x\n", Result);
                    os_panic(1);
                }
                
                registers->fpu_control_word = fp_control.FpControl;
                registers->fpu_status_word  = fp_control.FpStatus;
                registers->fpu_tag_word     = fp_control.FpTag;
            }
            
            {
                struct whv_register_value xmm_control = {0};
                Result = WHvGetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &(u32){/*WHvX64RegisterXmmControlStatus*/0x00001019}, 1, &xmm_control);
                if(Result < 0){
                    print("[WHvGetVirtualProcessorRegisters] Returned with Result 0x%x\n", Result);
                    os_panic(1);
                }
                
                registers->mxcsr       = xmm_control.MxCsr;
                registers->mxcsr_mask  = xmm_control.MxCsrMask;
            }
            
            {
                // 
                // Synchronize the local apic state.
                // 
                
                struct serialized_local_apic local_apic = {0};
                
                u32 size_written;
                Result = WHvGetVirtualProcessorInterruptControllerState2(Partition, virtual_processor_index, &local_apic, sizeof(local_apic), &size_written);
                if(Result < 0 || size_written != sizeof(local_apic)){
                    print("[WHvGetVirtualProcessorInterruptControllerState2] %x %x %x\n", Result, size_written, sizeof(local_apic));
                    os_panic(1);
                }
                
                // registers->local_apic.id_register = local_apic.id_register[0]; // Because we are currently emulating multiple cores with one core, this would get reset...
                registers->local_apic.version_register = local_apic.version_register[0];
                
                registers->local_apic.task_priority_register        = local_apic.task_priority_register[0];
                registers->local_apic.arbitration_priority_register = local_apic.arbitration_priority_register[0];
                registers->local_apic.processor_priority_register   = local_apic.processor_priority_register[0];
                registers->local_apic.end_of_interrupt_register     = local_apic.end_of_interrupt_register[0];
                registers->local_apic.remote_read_register          = local_apic.remote_read_register[0];
                registers->local_apic.local_destination_register    = local_apic.local_destination_register[0];
                registers->local_apic.destination_format_register   = local_apic.destination_format_register[0];
                registers->local_apic.spurious_interrupt_vector_register = local_apic.spurious_interrupt_vector_register[0];
                
                for(u32 index = 0; index < 8; index++){
                    registers->local_apic.in_service_register[index] = local_apic.in_service_register[index][0];
                    registers->local_apic.trigger_mode_register[index] = local_apic.trigger_mode_register[index][0];
                    registers->local_apic.interrupt_request_register[index] = local_apic.interrupt_request_register[index][0];
                }
                
                registers->local_apic.error_status_register = local_apic.error_status_register[0];
                
                registers->local_apic.interrupt_command_register.low  = local_apic.interrupt_command_register_0_31[0];
                registers->local_apic.interrupt_command_register.high = local_apic.interrupt_command_register_32_63[0];
                
                registers->local_apic.local_vector_table.corrected_machine_check_interrupt_register = local_apic.local_vector_table_corrected_machine_check_interrupt_register[0];
                registers->local_apic.local_vector_table.timer_register = local_apic.local_vector_table_timer_register[0];
                registers->local_apic.local_vector_table.thermal_sensor_register = local_apic.local_vector_table_thermal_sensor_register[0];
                registers->local_apic.local_vector_table.performance_monitoring_counters_register = local_apic.local_vector_table_performance_monitoring_counters_register[0];
                registers->local_apic.local_vector_table.lint0_register = local_apic.local_vector_table_lint0_register[0];
                registers->local_apic.local_vector_table.lint1_register = local_apic.local_vector_table_lint1_register[0];
                registers->local_apic.local_vector_table.error_register = local_apic.local_vector_table_error_register[0];
                
                registers->local_apic.timer_initial_count_register = local_apic.timer_initial_count_register[0];
                registers->local_apic.timer_current_count_register = local_apic.timer_current_count_register[0];
                registers->local_apic.timer_divide_configuration_register = local_apic.timer_divide_configuration_register[0];
                
                registers->local_apic.highest_pending_interrupt = apic__get_highest_set_bit(registers->local_apic.interrupt_request_register);
                registers->local_apic.highest_interrupt_in_service = apic__get_highest_set_bit(registers->local_apic.in_service_register);
            }
        }
        
        if(snapshot_mode_should_break_in_debugger){
            handle_debugger(context);
            snapshot_mode_should_break_in_debugger = 0;
        }
        
        // :exit_context_zero_instruction_length
        // 
        // @note: For some reason the 'InstructionLength' is not always set.
        //        If it is not, we have to fix it up.
        // 
        u32 instruction_length = ExitContext.VpContext.InstructionLength;
        
        switch(ExitContext.ExitReason){
            
            case /*WHvRunVpExitReasonMemoryAccess*/0x1:{
                struct{
                    u8 InstructionByteCount;
                    u8 Reserved[3];
                    u8 InstructionBytes[16];
                    
                    struct{
                        u32 AccessType  : 2;
                        u32 GpaUnmapped : 1;
                        u32 GvaValid    : 1;
                        u32 Reserved    : 28;
                    } AccessInfo;
                    
                    u64 GuestPhysicalAddress;
                    u64 GuestVirtualAddress;
                } *MemoryAccess = (void *)ExitContext.ExitData;
                
                // :exit_context_zero_instruction_length
                if(instruction_length == 0){
                    prefetch_instruction(context, registers->rip, MemoryAccess->InstructionBytes, sizeof(MemoryAccess->InstructionBytes));
                    instruction_length = decode_instruction(MemoryAccess->InstructionBytes).instruction_size;
                }
                
                u64 guest_physical_address = MemoryAccess->GuestPhysicalAddress & ~0xfff;
                
                if(guest_physical_address == /*IO APIC base*/0xfec00000){
                    struct instruction_information info = decode_instruction(MemoryAccess->InstructionBytes);
                    
                    // 
                    // @note: We were useing 'guest_read' and 'guest_write' here instead of 'io_apic_read'
                    //        and 'io_apic_write' to set the page table bits, but on AMD it seems 
                    //        'MemoryAccess->GuestVirtualAddress' is zero (and probably AccessInfo.GvaValid == 0).
                    // 
                    
                    // @cleanup: Check access size?
                    
                    u32 offset = (MemoryAccess->GuestPhysicalAddress & 0xfff);
                    
                    int success;
                    
                    if(MemoryAccess->AccessInfo.AccessType == /*WHvMemoryAccessRead*/0){
                        u32 value;
                        success = io_apic_read(context, offset, &value, sizeof(value));
                        
                        registers->gpr[info.reg] = value;
                    }else{
                        u32 value = 0;
                        if(info.immediate_size){
                            value = (u32)info.immediate;
                        }else{
                            value = (u32)registers->gpr[info.reg];
                        }
                        
                        success = io_apic_write(context, offset, &value, sizeof(value));
                    }
                    
                    if(!success){
                        print("Failed io_apic access:\n");
                        handle_debugger(context);
                    }
                    
                }else if(guest_physical_address == globals.vmbus.monitor_page2 || guest_physical_address == globals.vmbus.monitor_page1){
                    
                    // @cleanup: Maybe I should rename them into monitor_page0 and monitor_page1?
                    int monitor_id = (guest_physical_address == globals.vmbus.monitor_page2) ? 1 : 0;
                    int handled = 0;
                    
                    for(struct vmbus_channel *channel = globals.vmbus.channels; channel; channel = channel->next){
                        if(channel->monitor_id == monitor_id){
                            vmbus_handle_event(context, channel->connection_id);
                            handled = 1;
                        }
                    }
                    
                    if(!handled){
                        print("[" __FUNCTION__ "] [vmbus] Unhandled monitor_page%d access.\n", monitor_id + 1);
                    }
                    
                }else if(context->registers.vtl_state.current_vtl == 1 || (/*frame buffer*/0xf8000000 <= guest_physical_address && guest_physical_address <= 0xf8000000 + sizeof(frame_buffer))){ // @cleanup: Why do we have to have the address of the frame buffer here?
                    
                    if(MemoryAccess->AccessInfo.AccessType == /*WHvMemoryAccessRead*/0 || MemoryAccess->AccessInfo.AccessType == /*WHvMemoryAccessExecute*/2){
                        u8 *translated = get_physical_memory_for_read(context, guest_physical_address);
                        
                        if(context->crash){
                            print("Hypervisor tried to access physical address %p, but we have no mapping for it.\n", guest_physical_address);
                        }
                        
                        Result = WHvMapGpaRange(Partition, translated, guest_physical_address, 0x1000, /*WHvMapGpaRangeFlagRead*/1 | /*WHvMapGpaRangeFlagExecute*/4);
                        if(Result < 0){
                            print("[WHvMapGpaRange] GPA %p : HVA %p (Read/Execute) failed with result %x\n", guest_physical_address, translated, Result);
                        }
                    }else{
                        u8 *translated = get_physical_memory_for_write(context, guest_physical_address);
                        
                        if(context->crash){
                            print("Hypervisor tried to access physical address %p, but we have no mapping for it.\n", guest_physical_address);
                        }
                        
                        Result = WHvMapGpaRange(Partition, translated, guest_physical_address, 0x1000, /*WHvMapGpaRangeFlagRead*/1 | /*WHvMapGpaRangeFlagWrite*/2 | /*WHvMapGpaRangeFlagExecute*/4);
                        if(Result < 0){
                            print("[WHvMapGpaRange] GPA %p : HVA %p (Read/Write/Execute) failed with result %x\n", guest_physical_address, translated, Result);
                        }
                    }
                    
                    instruction_length = 0;
                    
                    // @note: For now randomly exit if the page was not contained in the dmp.
                    if(context->crash){
                        handle_debugger(context);
                    }
                }else if(guest_physical_address < globals.snapshot.physical_memory_size){
                    if(PRINT_VSM_EVENTS){
                        print("WHvRunVpExitReasonMemoryAccess phys = %p virt = %p access = %d unmapped = %d virt-valid = %d\n", MemoryAccess->GuestPhysicalAddress, MemoryAccess->GuestVirtualAddress, MemoryAccess->AccessInfo.AccessType, MemoryAccess->AccessInfo.GpaUnmapped, MemoryAccess->AccessInfo.GvaValid);
                        handle_debugger(context);
                    }
                }else{
                    print("Accessing guest physical memory outside of bounds (%p).\n", guest_physical_address);
                    handle_debugger(context);
                }
            }break;
            
            case /*WHvRunVpExitReasonX64IoPortAccess*/2:{
                
                struct{
                    u8 InstructionByteCount;
                    u8 Reserved[3];
                    u8 InstructionBytes[16];
                    
                    u32 IsWrite    : 1;
                    u32 AccessSize : 3;
                    u32 StringOp   : 1;
                    u32 RepPrefix  : 1;
                    u32 Reserved2  : 26;
                    
                    u16 PortNumber;
                    u16 Reserved3[3];
                    
                    u64 Rax;
                    u64 Rcx;
                    u64 Rsi;
                    u64 Rdi;
                    
                    struct segment ds;
                    struct segment es;
                } *IoPortAccessInfo = (void *)ExitContext.ExitData;
                
                // :exit_context_zero_instruction_length
                if(instruction_length == 0) instruction_length = decode_instruction(IoPortAccessInfo->InstructionBytes).instruction_size;
                
                assert(!IoPortAccessInfo->StringOp && !IoPortAccessInfo->RepPrefix);
                
                if(IoPortAccessInfo->IsWrite){
                    u32 AccessSizeBits = IoPortAccessInfo->AccessSize * 8;
                    u32 AccessBitMask = (u32)((1ull << AccessSizeBits) - 1); // @note: Do the shift in 64-bits, otherwise shifting by 32 is undefined.
                    u32 Value = (u32)IoPortAccessInfo->Rax & AccessBitMask;
                    
                    if(IoPortAccessInfo->PortNumber == /*reset/reboot*/0x433){
                        
                        print("Reset!\n");
                        
                        memset(&globals.vmbus, 0, sizeof(globals.vmbus));
                        memset(&context->registers, 0, sizeof(context->registers));
                        invalidate_translate_lookaside_buffers(context);
                        efi_setup_initial_state(context);
                        
                        
                        // @note: We fix up the descriptors here as the jit does not care about anything but the selector.
                        registers->cs = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->cs.selector);
                        registers->ss = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->ss.selector);
                        registers->ds = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->ds.selector);
                        registers->es = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->es.selector);
                        
                        registers->fs = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->fs.selector);
                        registers->gs = parse_segment_from_global_descriptor_table(context, registers->gdt_base, registers->gs.selector);
                        registers->gs.base = registers->gs_base;
                        registers->fs.base = registers->fs_base;
                        
                        // Why do we need to delete and reallocate the partition? I dunno!
                        s32 WHvDeletePartitionResult = WHvDeletePartition(Partition); // (I tried memsetting all physical memory instead, but it did not work)
                        if(WHvDeletePartitionResult < 0){
                            print("WHvDeletePartition failed with hresutl 0x%x\n", WHvDeletePartitionResult);
                        }
                        
                        globals.Partition = Partition = initialize_hypervisor();
                        
                        continue;
                    }
                    
                    write_to_port_helper(context, registers, IoPortAccessInfo->PortNumber, Value);
                }else{
                    read_from_port_helper(context, registers, IoPortAccessInfo->PortNumber, IoPortAccessInfo->AccessSize);
                }
                
            }break;
            
            case /*WHvRunVpExitReasonX64MsrAccess*/0x1000:{
                
                // 
                // We hit a rdmsr/wrmsr instruction. This only happens if the processor does not implement the MSR.
                // This essentially means it only happens for the hypervisor leafs (0x40000XXX).
                // Some of these leafs we handle specially in the hypervisor (the ones which have to do with interrupts; See the fast paths above).
                // The other MSRs we can just handle using 'helper_rdmsr/helper_wrmsr'. 
                // 
                
                struct{
                    struct{
                        u32 IsWrite  : 1;
                        u32 Reserved : 31;
                    } AccessInfo;
                    u32 MsrNumber;
                    u64 Rax;
                    u64 Rdx;
                } *MsrAccess = (void *)ExitContext.ExitData;
                
                if(MsrAccess->AccessInfo.IsWrite){
                    
                    u64 msr_input_value = (MsrAccess->Rdx << 32) | (u32)MsrAccess->Rax;
                    
                    switch(MsrAccess->MsrNumber){
                        default:{
                            // 
                            // These are _simple_ msrs (they dont touch interrupts), just handle them _normally_.
                            // 
                            helper_wrmsr(context, registers);
                        }break;
                        
                        case HV_X64_MSR_STIMER0_COUNT:{
                            if(context->registers.vtl_state.current_vtl == 0){
                                registers->hv_x64_msr_stimer0_count = msr_input_value;
                                set_next_timer_interrupt_time(context, registers);
                            }else{
                                if(PRINT_VSM_EVENTS) print("WARNING: Ignoring timer at vtl1\n");
                            }
                        }break;
                        case HV_X64_MSR_STIMER0_CONFIG:{
                            if(context->registers.vtl_state.current_vtl == 0){
                                registers->hv_x64_msr_stimer0_config = msr_input_value;
                                set_next_timer_interrupt_time(context, registers);
                            }else{
                                if(PRINT_VSM_EVENTS) print("WARNING: Ignoring timer config at vtl1\n");
                            }
                        }break;
                        
                        case HV_X64_MSR_EOM:{
                            helper_wrmsr(context, registers);
                        }break;
                    }
                }else{
                    
                    switch(MsrAccess->MsrNumber){
                        
                        default:{
                            helper_rdmsr(context, registers);
                        }break;
                        
                        
                        case BIOS_break:{
                            print("Bios breakpoint\n");
                            handle_debugger(context);
                        }break;
                        
                        case BIOS_crash:{
                            print("Bios Crashed!!\n");
                            handle_debugger(context);
                            os_panic(1);
                        }break;
                        
                        case HV_X64_MSR_GUEST_IDLE:{
                            // 
                            // @note: I disabled this code path by unsetting the "virtual guest idle" bit in the 
                            //        "Hypervisor Feature Identification" feature bitmap.
                            //        I will still leave it here because it may still be of use when using .DMP's
                            //        or .VMRS files as snapshots. But, it might have bit-rotted as it is not 
                            //        tested that often anymore.
                            //                                                               - Pascal Beyer 08.07.2024
                            
                            registers->rax = 0;
                            registers->rdx = 0;
                            
                            // :timer_interrupts
                            u64 time_reference_counter = calculate_time_reference_counter(context, registers);
                            
                            double time_to_sleep = (double)((s64)context->next_timer_interrupt_time_or_zero - (s64)time_reference_counter) * 100.0 / 1.0e+9;
                            if(time_to_sleep > 0){
                                s64 time_to_sleep_millies = (s64)(1000.0 * time_to_sleep);
                                if(time_to_sleep_millies > 16) time_to_sleep_millies = 16;
                                Sleep((u32)time_to_sleep_millies);
                            }
                            
                            pend_timer_interrupt(context, registers, context->next_timer_interrupt_time_or_zero);
                            
                            if(!(registers->hv_x64_msr_stimer0_config & /*periodic*/2)){
                                registers->hv_x64_msr_stimer0_count = 0;
                                
                                context->next_timer_interrupt_time_or_zero = 0;
                            }else{
                                context->next_timer_interrupt_time_or_zero = time_reference_counter + registers->hv_x64_msr_stimer0_count;
                            }
                        }break;
                    }
                }
            }break;
            case /*WHvRunVpExitReasonX64Cpuid*/0x1001:{
                helper_cpuid(context, registers);
            }break;
            case /*WHvRunVpExitReasonException*/0x1002:{
                
                struct{
                    u8 InstructionByteCount;
                    u8 Reserved[3];
                    u8 InstructionBytes[16];
                    
                    struct{
                        u32 ErrorCodeValid    : 1;
                        u32 SoftwareException : 1;
                        u32 Reserved : 30;
                    } AccessInfo;
                    
                    u8 ExceptionType;
                    u8 Reserved2[3];
                    u32 ErrorCode;
                    u64 ExceptionParameter;
                } *Exception = (void *)ExitContext.ExitData;
                
                if(Exception->ExceptionType == /*WHvX64ExceptionTypeDebugTrapOrFault*/1){
                    
                    //
                    // Single step exception, start by clearing the breakpoint, if we want to continue to single step,
                    // we have to reset it.
                    //
                    hypervisor_clear_oneshot_breakpoint(registers, registers->rip);
                    
                    if(context->hypervisor_require_auto_eoi){
                        // :auto_eoi
                        // 
                        // The last interrupt (SINT) had the 'auto_eoi' flag enabled.
                        // Here we perform this _auto eoi_.
                        context->hypervisor_require_auto_eoi = 0;
                        
                        hypervisor_perform_end_of_interrupt(context);
                        
                        if(!globals.single_stepping) continue;
                    }
                    
                    // If I understand correctly, the dr7 "GD - General Detect Enable" bit is reset on every debug exception.
                    // Hence, we have to reset it here.
                    registers->dr7 |= (1 << 13);
                    
                    if(registers->dr6 & (1 << 13)){
                        
                        // Debug register access detected.
                        // This happens when patchguard tries to make sure the debug registers are not set.
                        // Somewhere inside the exception handler of `KiBalanceSetManagerDeferredRoutine`.
                        
                        // Clear the Status bit.
                        registers->dr6 &= ~(1 << 13);
                        
                        struct instruction_information instruction = decode_instruction(Exception->InstructionBytes);
                        
                        int handled = 0;
                        if(instruction.augmented_opcode == /*mov regm, dreg*/0x121){
                            if(instruction.mod == MOD_REG){
                                handled = 1;
                                registers->gpr[instruction.regm] = 0; // Reading a debug register will always give 0.
                            }
                        }else if(instruction.augmented_opcode == /*mov dreg, regm*/0x123){
                            handled = 1;
                            
                            // 
                            // For user mode snapshotting, we use the debug registers to cause a breakpoint in the debugger.
                            // Hence, we must allow setting breakpoints here, but not allow removing breakpoints.
                            // 
                            
                            if(instruction.mod == MOD_REG){
                                // 
                                // Allow the very specific case of setting a local breakpoint using dr0.
                                // This is what the `user_snapshot.exe` does.
                                // 
                                if(instruction.reg == 0){
                                    // Save of the value we would have written to dr0, so we can write it below.
                                    context->potentially_usermode_snapshotting_breakpoint = registers->gpr[instruction.regm];
                                }
                                
                                if(instruction.reg == 7 && registers->gpr[instruction.regm] == 1){
                                    // Set the breakpoint the guest has requested as a oneshot breakpoint.
                                    hypervisor_set_breakpoint(context, registers, BREAKPOINT_execute, BREAKPOINT_FLAG_oneshot, context->potentially_usermode_snapshotting_breakpoint, 1, (struct string){0});
                                }
                            }
                        }
                        
                        if(handled){
                            registers->rip += instruction.instruction_size;
                            
                            if(!globals.single_stepping) continue;
                        }else{
                            print("WARNING: Unhandled Debug Register access!\n");
                        }
                    }
                    
                    if(Exception->InstructionBytes[0] == /*int1*/0xf1){
                        // If we hit a natural 0xf1, we want to stop, but then be able to continue.
                        registers->rip += 1;
                    }
                    
                    if(globals.print_trace){
                        if(!ExitContext.VpContext.ExecutionState.InterruptShadow) print_registers(context, globals.trace_file);
                        
                        u64 next_rip = get_address_of_next_instruction(context, registers);
                        
                        // 
                        // Stop the tracing, if we hit another breakpoint.
                        // 
                        
                        int is_terminating_breakpoint = 0;
                        is_terminating_breakpoint |= (registers->dr7 & 2) && registers->dr0 == next_rip;
                        is_terminating_breakpoint |= (registers->dr7 & 8) && registers->dr1 == next_rip;
                        is_terminating_breakpoint |= (registers->dr7 & 0x20) && registers->dr2 == next_rip;
                        is_terminating_breakpoint |= (registers->dr7 & 0x80) && registers->dr3 == next_rip;
                        if(is_terminating_breakpoint){
                            globals.print_trace = false;
                        }else{
                            hypervisor_set_breakpoint(context, registers, BREAKPOINT_execute, BREAKPOINT_FLAG_oneshot, next_rip, 1, (struct string){0});
                        }
                    }else{
                        handle_debugger(context);
                    }
                    
                    registers->dr6 &= ~0xf; // Clear the "Condition Detected" bits.
                    
                    // 
                    // Set the resume flag, so we don't immediately break again.
                    // 
                    registers->RF = 1;
                    
                    continue;
                }
                
                // 
                // If we have no special handling for the exception, just let the guest handle it.
                // 
                
                if(globals.single_stepping){
                    hypervisor_clear_oneshot_breakpoint(registers, get_address_of_next_instruction(context, registers));
                    hypervisor_set_breakpoint_on_vector(context, registers, /*vector*/Exception->ExceptionType);
                }
                
                // Reset the RF flag, as we don't want to have it set in the exception frame.
                registers->RF = 0;
                
                struct whv_register_value pending_event = {
                    .pending_event.EventPending       = 1,
                    .pending_event.EventType          = /*WHvX64PendingEventException*/0,
                    .pending_event.DeliverErrorCode   = Exception->AccessInfo.ErrorCodeValid,
                    .pending_event.Vector             = Exception->ExceptionType,
                    .pending_event.ErrorCode          = Exception->ErrorCode,
                    .pending_event.ExceptionParameter = Exception->ExceptionParameter,
                };
                
                Result = WHvSetVirtualProcessorRegisters(Partition, /*VirtualProcessorIndex*/virtual_processor_index, &(u32){/*WHvRegisterPendingEvent*/0x80000002}, 1, &pending_event);
                if(Result < 0){
                    print("[WHvSetVirtualProcessorRegisters] Could not set exception pending.\n");
                }
                continue;
            }break;
            
            case /*WHvRunVpExitReasonX64Rdtsc*/0x00001003:{
                // 
                // @note: This code-path is only used if `HYPERVISOR_EXIT_ON_RDTSC` is defined to one.
                //        Otherwise, we let the vm have the non-deterministic rdtsc so its way faster.
                // 
                
                struct {
                    u64 TscAux;
                    u64 VirtualOffset;
                    u64 Tsc;
                    u64 ReferenceTime;
                    struct {
                        u64 IsRdtscp : 1;
                        u64 Reserved : 64;
                    } RdtscInfo;
                } *ReadTsc = (void *)ExitContext.ExitData;
                
                registers->ia32_tsc += RDTSC_INCREMENT;
                
                registers->rax = (u32)(registers->ia32_tsc >>  0);
                registers->rdx = (u32)(registers->ia32_tsc >> 32);
                
                //
                // "Reads the current value of the processors time-stamp counter (a 64-bit MSR) into the EDX:EAX registers
                //  and also reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the ECX register."
                //
                
                if(ReadTsc->RdtscInfo.IsRdtscp){
                    registers->rcx = registers->ia32_tsc_aux;
                }
                
            }break;
            
            case /*WHvRunVpExitReasonHypercall*/0x00001005:{
                helper_vmcall(context, registers);
                if(registers->rip != ExitContext.VpContext.Rip){
                    // Vtl return or vtl call.
                    continue;
                }
            }break;
            
            case /*WHvRunVpExitReasonCanceled*/0x2001:{
                
                // Do not increment the rip.
                instruction_length = 0;
                
                if(globals.in_debugger){
                    globals.other_core_waiting_on_debugger = true;
                    WaitForSingleObject(globals.debugger_event, (u32)-1);
                    break;
                }
                
                // Don't allow any async events, while we are single stepping.
                if(globals.single_stepping) break;
                
                while(context->pending_interrupt_send < context->pending_interrupt_reserved){
                    struct pending_interrupt *pending_interrupt = &context->pending_interrupts[context->pending_interrupt_send++ % array_count(context->pending_interrupts)];
                    
                    if(pending_interrupt->target_vtl != context->registers.vtl_state.current_vtl) switch_vtl(&context->registers);
                    if(pending_interrupt->destination_mode == /*physical*/0 || (pending_interrupt->destination & (registers->local_apic.local_destination_register>>24))){
                        pend_interrupt(context, registers, pending_interrupt->vector_number);
                    }
                    if(pending_interrupt->target_vtl != context->registers.vtl_state.current_vtl) switch_vtl(&context->registers);
                }
                
                if(context->registers.vtl_state.current_vtl > 0) break;
                
                if(!context->wait_for_eom && context->pending_message_send < context->pending_message_reserved){
                    vmbus_process_pending_messages(context);
                }
                
                int did_something = hacky_display_input_handling(context);
                if(did_something) break; // For now, only ever initiate one event in an update.
                
                // :timer_interrupts
                
                u64 time_reference_counter = calculate_time_reference_counter(context, registers);
                if(context->next_timer_interrupt_time_or_zero && (time_reference_counter > context->next_timer_interrupt_time_or_zero)){
                    
                    pend_timer_interrupt(context, registers, context->next_timer_interrupt_time_or_zero);
                    
                    if(!(registers->hv_x64_msr_stimer0_config & /*periodic*/2)){
                        registers->hv_x64_msr_stimer0_count = 0;
                        
                        context->next_timer_interrupt_time_or_zero = 0;
                    }else{
                        context->next_timer_interrupt_time_or_zero = time_reference_counter + registers->hv_x64_msr_stimer0_count;
                    }
                }
            }break;
            
            default:{
                print("[Hypervisor] Unhandled ExitReason %x\n", ExitContext.ExitReason);
                
                if(ExitContext.ExitReason == /*WHvRunVpExitReasonInvalidVpRegisterValue*/5){
                    print("    -> Invalid Vp Register Value\n");
                }
                if(ExitContext.ExitReason == /*WHvRunVpExitReasonUnrecoverableException*/4){
                    print("    -> Unrecoverable Exception\n");
                }
                
                handle_debugger(context);
            }break;
        }
        
        if(context->crash){
            // This can happen for example for unhandled ports or msr's.
            // So handle this more gracefully.
            
            print_crash_information(context, &context->crash_information);
            handle_debugger(context);
        }
        
        // We should not change the `register->rip` anywhere and still end up in this _default_ case.
        assert(!instruction_length || ExitContext.VpContext.Rip == registers->rip);
        registers->rip += instruction_length;
        
        registers->RF = 0; // Disable the Resume Flag, as we have handled this instruction. Intel seems to do this for us, AMD does not.
    }
    
    assert(!"We somehow left the Hypervisor loop?");
}

void cancel_virtual_processor(void){
    
    // @note: We don't want to send these when we are single stepping and we are currently debugging the system.
    //        That's getting annoying. Otherwise, we do have to send these in case we are single stepping a hlt instruction.
    if(globals.in_debugger || (globals.single_stepping && IsDebuggerPresent())) return; 
    if(!globals.main_thread_context->use_hypervisor) return;
    
    s32 CancelResult = WHvCancelRunVirtualProcessor(globals.Partition, /*virtual processor index*/0, /*Flags (must be zero)*/0);
    if(CancelResult) print("CancelResult %x\n", CancelResult);
    
    CancelResult = WHvCancelRunVirtualProcessor(globals.Partition, /*virtual processor index*/1, /*Flags (must be zero)*/0);
    if(CancelResult) print("CancelResult %x\n", CancelResult);
}


